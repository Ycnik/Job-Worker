"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CookieAuthProvider = void 0;
const debug_1 = require("debug");
const got_1 = __importDefault(require("got"));
const lib_1 = require("../../lib");
const trace = (0, debug_1.debug)('camunda:cookie-auth');
/**
 * The `CookieAuthProvider` is an implementation of {@link IHeadersProvider} that
 * supports the [authentication used in C8run 8.7](https://docs.camunda.io/docs/apis-tools/camunda-api-rest/camunda-api-rest-authentication/#authentication-via-cookie-c8run-only).
 * It retrieves a cookie from the C8run login endpoint, and passes it in the
 * `cookie` header for subsequent requests.
 *
 * It does not handle token expiration or renewal. The cookie may be reset
 * manually by calling the `setToken` method.
 */
class CookieAuthProvider {
    constructor(options) {
        const config = lib_1.CamundaEnvironmentConfigurator.mergeConfigWithEnvironment(options?.config ?? {});
        this.authUrl = config.CAMUNDA_COOKIE_AUTH_URL;
        this.username = config.CAMUNDA_COOKIE_AUTH_USERNAME;
        this.password = config.CAMUNDA_COOKIE_AUTH_PASSWORD;
        this.rest = (0, lib_1.GetCustomCertificateBuffer)(config).then((certificateAuthority) => got_1.default.extend({
            retry: lib_1.GotRetryConfig,
            https: {
                certificateAuthority,
            },
            handlers: [lib_1.beforeCallHook],
            hooks: {
                beforeError: [(0, lib_1.gotBeforeErrorHook)(config)],
            },
        }));
    }
    async getHeaders(audienceType) {
        trace(`Token request for ${audienceType}`);
        if (!this.cookie) {
            const rest = await this.rest;
            this.cookie = await rest
                .post(this.authUrl, {
                searchParams: { username: this.username, password: this.password },
            })
                .then((response) => (this.cookie = response.headers['set-cookie']?.[0].split(';')[0]));
        }
        return { cookie: this.cookie };
    }
    /**
     * Forces a new login by resetting the cookie.
     * This method is useful for scenarios where the cookie has expired
     * or when you want to refresh the authentication.
     * It will reset the cookie to undefined, which will trigger a new login
     * the next time the getToken method is called.
     */
    async setToken() {
        this.cookie = undefined; // Reset the cookie to force a new login
        trace('Cookie reset');
    }
}
exports.CookieAuthProvider = CookieAuthProvider;
//# sourceMappingURL=CookieAuthProvider.js.map