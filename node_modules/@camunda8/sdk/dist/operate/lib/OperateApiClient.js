"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.OperateApiClient = void 0;
const debug_1 = require("debug");
const got_1 = __importDefault(require("got"));
const lib_1 = require("../../lib");
const OperateDto_1 = require("./OperateDto");
const parseSearchResults_1 = require("./parseSearchResults");
const trace = (0, debug_1.debug)('camunda:operate');
const OPERATE_API_VERSION = 'v1';
/**
 * The high-level client for Operate.
 * All constructor parameters for configuration are optional. If no configuration is provided, the SDK will use environment variables to configure itself.
 * See {@link CamundaSDKConfiguration} for the complete list of configuration parameters. Values can be passed in explicitly in code, or set via environment variables (recommended: separate configuration and application logic).
 * Explicitly set values will override environment variables, which are merged into the configuration.
 * @example
 * ```
 * const operate = new OperateApiClient()
 *
 * operate.searchProcessInstances({
 *     filter: {
 *         state: "ACTIVE"
 *     },
 *     size: 50
 * }).then(instances => {
 *     console.log(instances)
 * })
 * ```
 */
class OperateApiClient {
    /**
     * @example
     * ```
     * const operate = new OperateApiClient()
     * ```
     * @throws {RESTError} An error that may occur during API operations.
     */
    constructor(options) {
        const config = lib_1.CamundaEnvironmentConfigurator.mergeConfigWithEnvironment(options?.config ?? {});
        trace('options.config', options?.config);
        trace('config', config);
        this.oAuthProvider =
            options?.oAuthProvider ?? (0, lib_1.constructOAuthProvider)(config);
        this.userAgentString = (0, lib_1.createUserAgentString)(config);
        const baseUrl = (0, lib_1.RequireConfiguration)(config.CAMUNDA_OPERATE_BASE_URL, 'CAMUNDA_OPERATE_BASE_URL');
        const prefixUrl = `${baseUrl}/${OPERATE_API_VERSION}`;
        this.rest = (0, lib_1.GetCustomCertificateBuffer)(config).then((certificateAuthority) => got_1.default.extend({
            prefixUrl,
            retry: lib_1.GotRetryConfig,
            https: {
                certificateAuthority,
            },
            handlers: [lib_1.beforeCallHook],
            hooks: {
                beforeRetry: [
                    (0, lib_1.makeBeforeRetryHandlerFor401TokenRetry)(this.getHeaders.bind(this)),
                ],
                beforeError: [(0, lib_1.gotBeforeErrorHook)(config)],
                beforeRequest: config.middleware ?? [],
            },
        }));
        this.tenantId = config.CAMUNDA_TENANT_ID;
    }
    async getHeaders() {
        const authorization = await this.oAuthProvider.getHeaders('OPERATE');
        return {
            'content-type': 'application/json',
            ...authorization,
            'user-agent': this.userAgentString,
            accept: '*/*',
        };
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    addTenantIdToFilter(query, tenantId = this.tenantId // Example default value
    ) {
        const hasTenantIdInFilter = query.filter && 'tenantId' in query.filter;
        // If `filter` already has `tenantId`, return the original query as is.
        if (hasTenantIdInFilter) {
            return query;
        }
        // Otherwise, add or ensure `tenantId` in `filter`.
        return {
            ...query,
            filter: {
                ...query.filter,
                tenantId,
            },
        };
    }
    /**
     * Search and retrieve process definitions.
     *
     * [Camunda 8 Documentation](https://docs.camunda.io/docs/apis-clients/operate-api/#process-definition)
     * @throws {RESTError}
     * @example
     * ```
     * const query: Query<ProcessDefinition> = {
     *   filter: {},
     *   size: 50,
     *   sort: [
     *     {
     *       field: "bpmnProcessId",
     *       order: "ASC",
     *     },
     *    ],
     *  };
     * const operate = newOperateClient()
     * const defs = await operate.searchProcessDefinitions(query);
     * ```
     */
    async searchProcessDefinitions(query = {}) {
        const headers = await this.getHeaders();
        const json = this.addTenantIdToFilter(query);
        const rest = await this.rest;
        return rest
            .post('process-definitions/search', {
            json,
            headers,
            parseJson: (text) => (0, parseSearchResults_1.parseSearchResults)(text, OperateDto_1.ProcessDefinition),
        })
            .json();
    }
    /**
     *
     * Retrieve the metadata for a specific process definition, by key.
     * @throws {RESTError}
     * [Camunda 8 Documentation](https://docs.camunda.io/docs/apis-clients/operate-api/#process-definition)
     * @example
     * ```
     * const operate = new OperateApiClient()
     * const definition = await operate.getProcessDefinition(2251799817140074);
     *  ```
     */
    async getProcessDefinition(processDefinitionKey) {
        const headers = await this.getHeaders();
        const rest = await this.rest;
        return rest(`process-definitions/${processDefinitionKey}`, {
            headers,
            parseJson: (text) => (0, lib_1.losslessParse)(text, OperateDto_1.ProcessDefinition),
        }).json();
    }
    async getProcessDefinitionXML(processDefinitionKey) {
        const headers = await this.getHeaders();
        const rest = await this.rest;
        return rest(`process-definitions/${processDefinitionKey}/xml`, {
            headers,
        }).text();
    }
    /**
     *
     * @throws {RESTError}
     */
    async searchDecisionDefinitions(query) {
        const headers = await this.getHeaders();
        const json = this.addTenantIdToFilter(query);
        const rest = await this.rest;
        return rest
            .post('decision-definitions/search', {
            headers,
            parseJson: (text) => (0, parseSearchResults_1.parseSearchResults)(text, OperateDto_1.DecisionDefinition),
            json,
        })
            .json();
    }
    /**
     * @throws {RESTError}
     */
    async getDecisionDefinition(decisionDefinitionKey) {
        const headers = await this.getHeaders();
        const rest = await this.rest;
        return rest(`decision-definitions/${decisionDefinitionKey}`, {
            headers,
            parseJson: (text) => (0, lib_1.losslessParse)(text, OperateDto_1.DecisionDefinition),
        }).json();
    }
    /**
     * @throws {RESTError}
     */
    async searchDecisionInstances(query) {
        const headers = await this.getHeaders();
        const json = this.addTenantIdToFilter(query);
        const rest = await this.rest;
        return rest
            .post('decision-instances/search', {
            headers,
            parseJson: (text) => (0, parseSearchResults_1.parseSearchResults)(text, OperateDto_1.DecisionInstance),
            json,
        })
            .json();
    }
    /**
     * @throws {RESTError}
     */
    async getDecisionInstance(decisionInstanceKey) {
        const headers = await this.getHeaders();
        const rest = await this.rest;
        return rest(`decision-instances/${decisionInstanceKey}`, {
            headers,
            parseJson: (text) => (0, lib_1.losslessParse)(text, OperateDto_1.DecisionInstance),
        }).json();
    }
    /**
     * Search and retrieve process instances.
     * @throws {RESTError}
     * @example
     * ```
     * const operate = new OperateApiClient()
     * const query: Query<ProcessInstance>  = {
     *   filter: {
     *     processVersion: 1
     *   },
     *   size: 50,
     *   sort: [
     *     {
     *       field: "bpmProcessId",
     *       order: "ASC"
     *     }
     *   ]
     * }
     * const instances = await operate.searchProcessInstances(query)
     * console.log(`Found ${instances.total} instances`)
     */
    async searchProcessInstances(query = {}) {
        const headers = await this.getHeaders();
        const json = this.addTenantIdToFilter(query);
        const rest = await this.rest;
        try {
            return rest
                .post('process-instances/search', {
                json,
                headers,
                parseJson: (text) => (0, parseSearchResults_1.parseSearchResults)(text, OperateDto_1.ProcessInstance),
            })
                .json();
        }
        catch (e) {
            throw new Error(e.message);
        }
    }
    /**
     *
     * Retrieve a specific process instance by id.
     * @throws {RESTError}
     * @example
     * ```
     * const operate = new OperateApiClient()
     * const instance = await operate.getProcessInstance(2251799819847322)
     * ```
     */
    async getProcessInstance(processInstanceKey) {
        const headers = await this.getHeaders();
        const rest = await this.rest;
        return rest(`process-instances/${processInstanceKey}`, {
            headers,
            parseJson: (text) => (0, lib_1.losslessParse)(text, OperateDto_1.ProcessInstance),
        }).json();
    }
    /**
     * Delete a specific process instance by key.
     * @throws {RESTError}
     * @example
     * ```
     * const operate = new OperateApiClient()
     * await operate.deleteProcessInstance(2251799819847322)
     * ```
     */
    async deleteProcessInstance(processInstanceKey) {
        const headers = await this.getHeaders();
        const rest = await this.rest;
        try {
            const res = rest.delete(`process-instances/${processInstanceKey}`, {
                headers,
                throwHttpErrors: false,
                parseJson: (text) => (0, lib_1.losslessParse)(text, OperateDto_1.ChangeStatus),
            });
            res.catch((e) => console.log(e));
            return res.json();
        }
        catch (e) {
            throw new Error(e.message);
        }
    }
    /**
     * Get the statistics for a process instance, grouped by flow nodes
     * @throws {RESTError}
     */
    async getProcessInstanceStatistics(processInstanceKey) {
        const headers = await this.getHeaders();
        const rest = await this.rest;
        return rest(`process-instances/${processInstanceKey}/statistics`, {
            headers,
            parseJson: (text) => (0, lib_1.losslessParse)(text, OperateDto_1.ProcessInstanceStatistics),
        }).json();
    }
    /**
     * Get sequence flows of process instance by key
     * @throws {RESTError}
     */
    async getProcessInstanceSequenceFlows(processInstanceKey) {
        const headers = await this.getHeaders();
        const rest = await this.rest;
        return rest(`process-instances/${processInstanceKey}/sequence-flows`, {
            headers,
        }).json();
    }
    /**
     *
     * Search and retrieve incidents.
     * @throws {RESTError}
     * @example
     * ```
     * const operate = new OperateApiClient()
     * const query: Query<Incident> = {
     *   filter: {
     *     state: "ACTIVE"
     *   },
     *   size: 50,
     *   sort: [
     *     {
     *       field: "creationTime",
     *       order: "ASC"
     *     }
     *   ]
     * }
     * const incidents = operate.searchIncidents(query)
     * ```
     */
    async searchIncidents(query = {}) {
        const headers = await this.getHeaders();
        const json = this.addTenantIdToFilter(query);
        const rest = await this.rest;
        return rest
            .post('incidents/search', {
            json,
            headers,
            parseJson: (text) => (0, parseSearchResults_1.parseSearchResults)(text, OperateDto_1.Incident),
        })
            .json();
    }
    /**
     *
     * Retrieve an incident by incident key.
     * @throws {RESTError}
     * @example
     * ```
     * const operate = new OperateApiClient()
     * const incident = await operate.getIncident(2251799818436725)
     * console.log(incident.message)
     * ```
     */
    async getIncident(key) {
        const headers = await this.getHeaders();
        const rest = await this.rest;
        return rest(`incidents/${key}`, {
            headers,
            parseJson: (text) => (0, lib_1.losslessParse)(text, OperateDto_1.Incident),
        }).json();
    }
    /**
     * @throws {RESTError}
     */
    async searchFlownodeInstances(query) {
        const headers = await this.getHeaders();
        const json = this.addTenantIdToFilter(query);
        const rest = await this.rest;
        return rest
            .post('flownode-instances/search', {
            headers,
            json,
            parseJson: (text) => (0, parseSearchResults_1.parseSearchResults)(text, OperateDto_1.FlownodeInstance),
        })
            .json();
    }
    /**
     * @throws {RESTError}
     */
    async getFlownodeInstance(key) {
        const headers = await this.getHeaders();
        const rest = await this.rest;
        return rest(`flownode-instances/${key}`, {
            headers,
            parseJson: (text) => (0, lib_1.losslessParse)(text, OperateDto_1.FlownodeInstance),
        }).json();
    }
    /**
     * @throws {RESTError}
     */
    async searchVariables(query) {
        const headers = await this.getHeaders();
        const json = this.addTenantIdToFilter(query);
        const rest = await this.rest;
        return rest
            .post('variables/search', {
            headers,
            json,
            parseJson: (text) => (0, parseSearchResults_1.parseSearchResults)(text, OperateDto_1.Variable),
        })
            .json();
    }
    /**
     * Retrieve the variables for a Process Instance, given its key. Documentation: https://docs.camunda.io/docs/apis-tools/operate-api/specifications/search/
     * @throws {RESTError}
     * @param processInstanceKey
     * @returns
     */
    async getVariablesforProcess(processInstanceKey, options = {}) {
        const headers = await this.getHeaders();
        const body = {
            filter: {
                processInstanceKey,
            },
            size: options.size ?? 1000,
            searchAfter: options.searchAfter,
            sort: options.sort ?? [{ field: 'name' }],
        };
        const rest = await this.rest;
        return rest
            .post('variables/search', {
            headers,
            body: (0, lib_1.losslessStringify)(body),
        })
            .json();
    }
    /**
     * Retrieve the variables for a Process Instance as an object, given its key
     * @param processInstanceKey
     * @throws {RESTError}
     */
    async getJSONVariablesforProcess(processInstanceKey, size = 1000) {
        const headers = await this.getHeaders();
        const body = {
            filter: {
                processInstanceKey,
            },
            size,
        };
        const rest = await this.rest;
        const vars = await rest
            .post('variables/search', {
            headers,
            body: (0, lib_1.losslessStringify)(body),
        })
            .json();
        return vars.items.reduce((prev, curr) => ({
            ...prev,
            [curr.name]: this.safeJSONparse(curr.value),
        }), {});
    }
    safeJSONparse(thing) {
        try {
            return JSON.parse(thing);
        }
        catch (e) {
            console.log(e);
            console.log(thing);
            return thing;
        }
    }
    /**
     *
     * Return a variable identified by its variable key
     * @throws {RESTError}
     * @returns
     */
    async getVariables(variableKey) {
        const headers = await this.getHeaders();
        const rest = await this.rest;
        return rest(`variables/${variableKey}`, {
            headers,
            parseJson: (text) => (0, lib_1.losslessParse)(text, OperateDto_1.Variable),
        }).json();
    }
    /**
     * @throws {RESTError}
     */
    async searchDecisionRequirements(query) {
        const headers = await this.getHeaders();
        const json = this.addTenantIdToFilter(query);
        const rest = await this.rest;
        return rest
            .post('drd/search', {
            headers,
            json,
            parseJson: (text) => (0, parseSearchResults_1.parseSearchResults)(text, OperateDto_1.DecisionRequirements),
        })
            .json();
    }
    async getDecisionRequirements(key) {
        const headers = await this.getHeaders();
        const rest = await this.rest;
        return rest(`drd/${key}`, {
            headers,
            parseJson: (text) => (0, lib_1.losslessParse)(text, OperateDto_1.DecisionRequirements),
        }).json();
    }
    /**
     * @throws {RESTError}
     */
    async getDecisionRequirementsXML(key) {
        const headers = await this.getHeaders();
        const rest = await this.rest;
        return rest(`drd/${key}/xml`, {
            headers,
        }).text();
    }
}
exports.OperateApiClient = OperateApiClient;
//# sourceMappingURL=OperateApiClient.js.map